# 管理器架构设计

## 概述
为了降低代码耦合度，提高可维护性，主题和标题功能采用了管理器模式进行重构。

## 架构组件

### 1. ThemeManager (主题管理器)
**位置**: `src/managers/theme_manager.py`

**职责**:
- 主题的存储和管理
- 主题验证（长度、格式等）
- 主题状态查询
- 主题重置功能

**主要方法**:
- `get_current_theme()`: 获取当前主题
- `set_theme(theme)`: 设置新主题
- `reset_theme()`: 重置为默认主题

### 2. TitleManager (标题管理器)
**位置**: `src/managers/title_manager.py`

**职责**:
- 标题的存储和管理
- 标题更新逻辑
- UI操作封装
- 冷却时间管理
- UI解析和初始化

**主要方法**:
- `get_current_title()`: 获取当前标题
- `get_next_title()`: 获取下一个标题
- `get_title_to_update()`: 获取要更新的标题（包含UI解析）
- `set_next_title(title)`: 设置下一个标题
- `update_title_ui(title, theme)`: 执行UI更新
- `force_update_title(title, theme)`: 强制更新（绕过冷却时间）
- `can_update_now()`: 检查是否可以立即更新
- `_parse_title_from_ui()`: 从UI解析房间标题
- `_initialize_from_ui()`: 启动时初始化

### 3. ThemeCommand (主题命令)
**位置**: `src/commands/theme.py`

**职责**:
- 处理用户命令
- 调用主题管理器
- 触发标题更新
- 错误处理和响应

### 4. TitleCommand (标题命令)
**位置**: `src/commands/title.py`

**职责**:
- 处理用户命令
- 调用标题管理器
- 定期更新检查
- 错误处理和响应

## 设计优势

### 1. 解耦合
- 命令层只负责用户交互
- 业务逻辑集中在管理器层
- UI操作封装在标题管理器中

### 2. 可复用性
- 管理器可以被其他组件复用
- 主题和标题功能独立管理
- 便于单元测试

### 3. 可维护性
- 职责分离清晰
- 代码结构更清晰
- 便于扩展新功能

### 4. 状态一致性
- 管理器确保状态一致性
- 避免命令间的直接依赖
- 统一的错误处理
- UI更新后自动同步主题管理器状态

## 数据流

### 主题更新流程
1. 用户输入 `:theme 音乐`
2. ThemeCommand 接收命令
3. ThemeManager 验证并更新主题
4. ThemeCommand 调用 TitleManager 更新房间名称
5. TitleManager 执行UI操作

### 标题更新流程
1. 用户输入 `:title 经典老歌`
2. TitleCommand 接收命令
3. TitleManager 设置下一个标题
4. 定期检查时执行UI更新
5. UI更新成功后同步主题管理器状态

### UI解析初始化流程
1. 应用启动时创建 TitleManager
2. 检查当前标题和下一个标题是否为空
3. 如果为空，从UI解析房间标题
4. 解析 `主题｜标题` 格式，更新管理器状态
5. 自动初始化主题管理器和当前标题

## 扩展性

### 添加新功能
- 在管理器中添加新方法
- 命令层调用管理器方法
- 保持架构一致性

### 添加新管理器
- 遵循现有的管理器模式
- 实现必要的接口方法
- 在命令中集成

## 最佳实践

### 1. 管理器设计
- 单一职责原则
- 提供清晰的公共接口
- 适当的错误处理

### 2. 命令设计
- 专注于用户交互
- 委托业务逻辑给管理器
- 统一的响应格式

### 3. 状态管理
- 管理器负责状态存储
- 避免命令间的状态共享
- 使用管理器方法访问状态
